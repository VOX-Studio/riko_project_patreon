import type { GGUFTypedMetadata, GGUFParseOutput } from "./types";
export type { MetadataBaseValue, MetadataValue, Version, GGUFMetadata, GGUFTypedMetadata, GGUFTensorInfo, GGUFParseOutput, GGUFMetadataOptions, } from "./types";
export { GGUFValueType, GGMLQuantizationType, Architecture } from "./types";
export { GGUF_QUANT_DESCRIPTIONS } from "./quant-descriptions";
export { parseGGUFQuantLabel, GGUF_QUANT_RE, GGUF_QUANT_RE_GLOBAL, GGUF_QUANT_ORDER, findNearestQuantType, GGMLFileQuantizationType, } from "@huggingface/tasks";
export declare const RE_GGUF_FILE: RegExp;
export declare const RE_GGUF_SHARD_FILE: RegExp;
export interface GgufShardFileInfo {
    prefix: string;
    shard: string;
    total: string;
}
export declare function parseGgufShardFilename(filename: string): GgufShardFileInfo | null;
export declare function gguf(uri: string, params: {
    fetch?: typeof fetch;
    additionalFetchHeaders?: Record<string, string>;
    typedMetadata: true;
    allowLocalFile?: boolean;
}): Promise<GGUFParseOutput & {
    typedMetadata: GGUFTypedMetadata;
}>;
export declare function gguf(uri: string, params: {
    fetch?: typeof fetch;
    additionalFetchHeaders?: Record<string, string>;
    typedMetadata: true;
    computeParametersCount: true;
    allowLocalFile?: boolean;
}): Promise<GGUFParseOutput & {
    parameterCount: number;
    typedMetadata: GGUFTypedMetadata;
}>;
export declare function gguf(uri: string, params: {
    fetch?: typeof fetch;
    additionalFetchHeaders?: Record<string, string>;
    computeParametersCount: true;
    allowLocalFile?: boolean;
}): Promise<GGUFParseOutput & {
    parameterCount: number;
}>;
export declare function gguf(uri: string, params?: {
    fetch?: typeof fetch;
    additionalFetchHeaders?: Record<string, string>;
    allowLocalFile?: boolean;
}): Promise<GGUFParseOutput>;
/**
 * Serialize GGUF header including metadata and alignment.
 *
 * @param typedMetadata - The typed metadata to serialize
 * @param options - Serialization options
 * @returns A Uint8Array containing the GGUF header with proper alignment
 */
export declare function serializeGgufMetadata(typedMetadata: GGUFTypedMetadata, options?: {
    /**
     * Whether to use little endian byte order
     * @default true
     */
    littleEndian?: boolean;
    /**
     * Alignment for tensor data
     * @default GGUF_DEFAULT_ALIGNMENT (32)
     */
    alignment?: number;
}): Uint8Array;
/**
 * Reconstructs a complete GGUF header by combining updated metadata with original tensor info.
 * This function handles the entire process of serializing new metadata, extracting original tensor info,
 * and properly padding the final header for alignment.
 *
 * @param originalFileBlob - The original GGUF file blob
 * @param updatedMetadata - The updated typed metadata
 * @param options - Reconstruction options
 * @returns Promise resolving to the new header blob ready for file editing
 */
export declare function buildGgufHeader(originalFileBlob: Blob, updatedMetadata: GGUFTypedMetadata, options: {
    /** Whether to use little endian byte order */
    littleEndian: boolean;
    /** Tensor info byte range [start, endBeforePad] from parsing */
    tensorInfoByteRange: [number, number];
    /** Alignment for tensor data (default: GGUF_DEFAULT_ALIGNMENT (32)) */
    alignment?: number;
}): Promise<Blob>;
export declare function ggufAllShards(url: string, params?: {
    /**
     * Custom fetch function to use instead of the default one, for example to use a proxy or edit headers.
     */
    fetch?: typeof fetch;
    additionalFetchHeaders?: Record<string, string>;
    parallelDownloads?: number;
    allowLocalFile?: boolean;
}): Promise<{
    shards: GGUFParseOutput[];
    parameterCount: number;
}>;
//# sourceMappingURL=gguf.d.ts.map